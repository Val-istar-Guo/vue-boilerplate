#!/usr/bin/env node
const program = require('commander')
const { resolve } = require('path')
const fs = require('fs-extra')
const log = require('../src/utils/log')
const mili = require('../src/mili')
const { version } = require('../package.json')


program
  .version(version)

const absolutize = val => resolve(val)

program
  .command('init [repository]')
  .usage('[options] <repository>')
  .description('initialize the project')
  .option('-n --app-name [app_name]', 'Set your app name.')
  .option('--no-deps', 'Need not install dependencies', false)
  .option('--force')
  .option('-v --version [version]', 'Set the template version')
  .option('--cwd [cwd]', 'Set the current work directory', absolutize)
  .action((repository, option) => {
    if (!repository) program.help()

    const { appName, force = false, deps = true, cwd } = option

    let version
    if (typeof option.version === 'string') version = option.version
    if (cwd) fs.ensureDir(cwd)

    return mili.init({ cwd, name: appName, force, repository, version, noDeps: !deps })
      .then(() => log.info('initialize complete'))
      .catch(err => log.error('program', 'initialize break', err))
  })

const collect = (val, memo) => {
  memo.push(val)
  return memo
}

program
  .command('upgrade')
  .description('upgrade the template')
  .option('--force')
  .option('--no-deps', 'Need not install dependencies', false)
  .option('-r, --recursive', 'Upgrade recursive all subfolder')
  .option('--ignore [file]', 'the folder need not search', collect, [])
  .option('--cwd [cwd]', 'Set the current work directory', absolutize)
  .action(option => {
    const { cwd, force = false, deps = true, recursive, ignore } = option
    if (cwd && !fs.pathExistsSync(cwd)) {
      log.error('cwd', `No such directory: ${cwd}`)
      return
    }

    mili.upgrade({ cwd, force, noDeps: !deps, recursive, ignore })
      .catch(err => log.error('program', 'upgrade break', err))
  })

program
  .command('update')
  .description('Update the project with the current version of the template')
  .option('--force')
  .option('-v --version [version]', 'Set the template version')
  .option('--no-deps', 'Need not install dependencies', false)
  .option('--cwd [cwd]', 'Set the current work directory', absolutize)
  .action(option => {
    const { cwd, force = false, deps = true } = option

    let version
    if (typeof option.version === 'string') version = option.version
    if (cwd && !fs.pathExistsSync(cwd)) {
      log.error('cwd', `No such directory: ${cwd}`)
      return
    }

    mili.update({ cwd, force, version, noDeps: !deps })
      .then(() => log.info('update complete'))
      .catch(err => log.error('program', 'update break', err))
  })

program
  .command('clean')
  .description('Clean the cache of mili')
  .action(() => {
    log.info('begin clean')
    mili.clean()
      .then(() => log.info('clean complete'))
      .catch(err => log.error('clean', 'clean break', err))
  })

program
  .command('outdated')
  .description('Check template is outdated')
  .action(() => {
    mili.outdated()
  })


// error on unknown commands
program.on('command:*', () => {
  log.error('command', 'Invalid command: %s\nSee --help for a list of available commands.', program.args.join(' '))
  process.exit(1)
})


program.parse(process.argv)

if (!process.argv.slice(2).length) program.help()
